export = RepoAPI;
declare class RepoAPI {
    /**
     * @param {Object} config
     * @param {GCLock} config.gcLock
     * @param {Pin} config.pin
     * @param {Repo} config.repo
     * @param {Refs} config.refs
     */
    constructor({ gcLock, pin, repo, refs }: {
        gcLock: GCLock;
        pin: Pin;
        repo: Repo;
        refs: Refs;
    });
    gc: (_options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<import("./gc").Err | import("./gc").BlockID>;
    stat: (options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<{
        numObjects: number;
        repoSize: number;
        repoPath: string;
        version: string;
        storageMax: number;
    }>;
    version: (options: import("ipfs-core-types").AbortOptions) => Promise<number>;
}
declare namespace RepoAPI {
    export { GCLock, Pin, Repo, Refs, AbortOptions };
}
type GCLock = {
    readLock: () => Promise<() => void>;
    writeLock: () => Promise<() => void>;
};
type Pin = import("../pin");
type Repo = import("ipfs-core-types/src/repo").Repo<import("../config").IPFSConfig>;
type Refs = (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("../refs").RefsOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<{
    ref: string;
    err?: null | undefined;
} | {
    ref?: undefined;
    err: Error;
}>;
type AbortOptions = import("ipfs-core-types").AbortOptions;
//# sourceMappingURL=index.d.ts.map