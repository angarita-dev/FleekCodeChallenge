export = PinManager;
declare class PinManager {
    /**
     * Throws an error if the pin type is invalid
     *
     * @param {any} type
     * @returns {type is PinType}
     */
    static checkPinType(type: any): type is "direct" | "recursive" | "indirect";
    /**
     * @param {Object} config
     * @param {import('.').Repo} config.repo
     * @param {import('.').DagReader} config.dagReader
     */
    constructor({ repo, dagReader }: {
        repo: import('.').Repo;
        dagReader: import('.').DagReader;
    });
    repo: import("ipfs-core-types/src/repo").Repo<import("../config").IPFSConfig>;
    dag: import("../dag").DagReader;
    log: debug.Debugger;
    directPins: Set<any>;
    recursivePins: Set<any>;
    /**
     * @private
     * @param {CID} cid
     * @param {Object} options
     * @param {boolean} [options.preload]
     */
    private _walkDag;
    /**
     * @param {CID} cid
     * @param {PinOptions & AbortOptions} [options]
     * @returns {Promise<void>}
     */
    pinDirectly(cid: import("cids"), options?: (PinOptions & import("ipfs-core-types").AbortOptions) | undefined): Promise<void>;
    /**
     * @param {CID} cid
     * @param {AbortOptions} [options]
     * @returns {Promise<void>}
     */
    unpin(cid: import("cids"), options?: import("ipfs-core-types").AbortOptions | undefined): Promise<void>;
    /**
     * @param {CID} cid
     * @param {PreloadOptions & PinOptions & AbortOptions} [options]
     * @returns {Promise<void>}
     */
    pinRecursively(cid: import("cids"), options?: (PreloadOptions & PinOptions & import("ipfs-core-types").AbortOptions) | undefined): Promise<void>;
    /**
     * @param {AbortOptions} [options]
     * @returns {AsyncIterable<{ cid: CID, metadata: any }>}
     */
    directKeys(options?: import("ipfs-core-types").AbortOptions | undefined): AsyncIterable<{
        cid: import("cids");
        metadata: any;
    }>;
    /**
     * @param {AbortOptions} [options]
     * @returns {AsyncIterable<{ cid: CID, metadata: any }>}
     */
    recursiveKeys(options?: import("ipfs-core-types").AbortOptions | undefined): AsyncIterable<{
        cid: import("cids");
        metadata: any;
    }>;
    /**
     * @param {Object} options
     * @param {boolean} [options.preload]
     */
    indirectKeys({ preload }: {
        preload?: boolean | undefined;
    }): AsyncGenerator<any, void, unknown>;
    /**
     * @param {CID} cid
     * @param {PinQueryType|PinQueryType[]} types
     * @param {AbortOptions} [options]
     */
    isPinnedWithType(cid: import("cids"), types: PinQueryType | PinQueryType[], options?: import("ipfs-core-types").AbortOptions | undefined): Promise<{
        cid: import("cids");
        pinned: boolean;
        reason: "direct" | "recursive";
        metadata: any;
        parent?: undefined;
    } | {
        cid: import("cids");
        pinned: boolean;
        reason: "indirect";
        parent: any;
        metadata?: undefined;
    } | {
        cid: import("cids");
        pinned: boolean;
        reason?: undefined;
        metadata?: undefined;
        parent?: undefined;
    }>;
    /**
     * @param {CID} cid
     * @param {PreloadOptions & AbortOptions} options
     */
    fetchCompleteDag(cid: import("cids"), options: PreloadOptions & AbortOptions): Promise<void>;
}
declare namespace PinManager {
    export { PinTypes, PinType, PinQueryType, PinOptions, PreloadOptions, AbortOptions };
}
type PinOptions = {
    metadata?: any;
};
type PreloadOptions = {
    preload?: boolean | undefined;
};
type PinQueryType = "direct" | "recursive" | "indirect" | "all";
type AbortOptions = import("ipfs-core-types").AbortOptions;
declare namespace PinTypes {
    const direct: 'direct';
    const recursive: 'recursive';
    const indirect: 'indirect';
    const all: 'all';
}
type PinType = "direct" | "recursive" | "indirect";
//# sourceMappingURL=pin-manager.d.ts.map